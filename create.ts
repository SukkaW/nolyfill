'use strict';

import fsPromises from 'fs/promises';
import path from 'path';
import ezspawn from '@jsdevtools/ez-spawn';
import { PathScurry } from 'path-scurry';
import colors from 'picocolors';
import { dequal } from 'dequal';
import { fileExists, compareAndWriteFile } from '@nolyfill/internal';
import { transform } from '@swc/core';

import type { PackageJson } from 'type-fest';

/**
 * The package.json inside the project has a non-nullable "version" field,
 * and a known "pnpm.overrides".
 *
 * PackageJson type can not be extend since it is a union type.
 */
type CurrentPackageJson = PackageJson & {
  version: string,
  pnpm: {
    overrides: Record<string, string>
  } & Record<string, unknown>
};

const currentPackageJsonPromise: Promise<CurrentPackageJson> = fsPromises.readFile('./package.json', { encoding: 'utf-8' })
  .then(t => JSON.parse(t) as CurrentPackageJson);

interface VirtualPackage {
  path: string,
  files: Record<string, string>,
  packageJson: PackageJson
}

const autoGeneratedPackagesList = [
  ['array-includes'],
  ['array.prototype.findlastindex'],
  ['array.prototype.findlast'],
  ['array.prototype.at']
  //   ['string.prototype.at', `String.prototype.at || function at(n) {
  //   n = Math.trunc(n) || 0;
  //   if (n < 0) n += this.length;
  //   if (n < 0 || n >= this.length) return undefined;
  //   return String.prototype.charAt.call(this, n);
  // }`, false],
  //   ['array.prototype.flat', 'Array.prototype.flat', false],
  //   ['array.prototype.flatmap', 'Array.prototype.flatMap', false],
  //   ['arraybuffer.prototype.slice', 'ArrayBuffer.prototype.slice', false],
  //   ['function.prototype.name', 'Function.prototype.name', false],
  //   ['has', 'Object.prototype.hasOwnProperty', false],
  //   ['object-keys', 'Object.keys', true],
  //   ['object.assign', 'Object.assign', true],
  //   ['object.entries', 'Object.entries', true],
  //   ['object.fromentries', 'Object.fromEntries', true],
  //   ['object.hasown', 'Object.hasOwn || require(\'@nolyfill/shared\').uncurryThis(Object.prototype.hasOwnProperty)', true, { '@nolyfill/shared': 'workspace:*' }],
  //   ['object.values', 'Object.values', true],
  //   ['string.prototype.trim', 'String.prototype.trim', false],
  //   ['string.prototype.trimend', 'String.prototype.trimEnd', false],
  //   ['string.prototype.trimstart', 'String.prototype.trimStart', false],
  //   ['string.prototype.trimleft', 'String.prototype.trimLeft', false],
  //   ['string.prototype.trimright', 'String.prototype.trimRight', false],
  //   ['string.prototype.matchall', 'String.prototype.matchAll', false],
  //   ['regexp.prototype.flags', 'RegExp.prototype.flags', false],
  //   // ['globalthis', 'globalThis', true], // globalthis package's entrypoint is a function, not the implementation
  //   ['array.prototype.tosorted', `Array.prototype.toSorted || function (compareFn) {
  //   const o = Object(this);
  //   const l = Number(o.length);
  //   const a = new Array(l);
  //   for (let i = 0; i < l; i++) {
  //     a[i] = o[i];
  //   }
  //   Array.prototype.sort.call(a, compareFn);
  //   return a;
  // }`, false],
  //   ['object.groupby', `Object.groupBy || function (items, callbackfn) {
  //   const o = Object.create(null);
  //   let k = 0;
  //   for (const value of items) {
  //     const key = callbackfn(value, k++);
  //     if (key in o) {
  //       Array.prototype.push.call(o[key], value);
  //     } else {
  //       o[key] = [value];
  //     }
  //   }
  //   return o;
  // }`, true],
  //   ['array.prototype.find', 'Array.prototype.find', false],
  //   ['array.from', 'Array.from', true],
  //   ['string.prototype.padend', 'String.prototype.padEnd', false],
  //   ['string.prototype.padstart', 'String.prototype.padStart', false],
  //   ['object.getownpropertydescriptors', 'Object.getOwnPropertyDescriptors', true],
  //   ['array.prototype.reduce', 'Array.prototype.reduce', false],
  //   ['object-is', 'Object.is', true],
  //   ['reflect.ownkeys', 'Reflect.ownKeys', true],
  //   // ['array.prototype.filter', 'Array.prototype.filter', false],
  //   ['string.prototype.replaceall', 'String.prototype.replaceAll', false],
  //   // ['array.prototype.map', 'Array.prototype.map', false],
  //   ['reflect.getprototypeof', 'Reflect.getPrototypeOf', true],
  //   // ['object.getprototypeof', 'Object.getPrototypeOf', true]
  //   ['es-aggregate-error', `typeof AggregateError === 'function'
  //   ? AggregateError
  //   : (() => {
  //     function AggregateError(errors, message) {
  //       const error = new Error(message);
  //       Object.setPrototypeOf(error, AggregateError.prototype);
  //       delete error.constructor;
  //       Object.defineProperty(error, 'errors', { value: Array.from(errors) });
  //       return error;
  //     }
  //     Object.defineProperty(AggregateError, 'prototype', { writable: false });
  //     Object.defineProperties(AggregateError.prototype, {
  //       constructor: {
  //         enumerable: false,
  //         configurable: true,
  //         writable: true,
  //         value: AggregateError
  //       },
  //       message: {
  //         enumerable: false,
  //         configurable: true,
  //         writable: true,
  //         value: ''
  //       },
  //       name: {
  //         enumerable: false,
  //         configurable: true,
  //         writable: true,
  //         value: 'AggregateError'
  //       }
  //     });
  //     Object.setPrototypeOf(AggregateError.prototype, Error.prototype);
  //     return AggregateError;
  //   })()`, true],
  ['promise.any', { '@nolyfill/es-aggregate-error': 'workspace:*' }, '>=12.4.0'],
  //   ['promise.allsettled', `Promise.allSettled || function allSettled(iterable) {
  //   const $reject = Promise.reject.bind(this);
  //   const $resolve = Promise.resolve.bind(this);
  //   const $all = Promise.all.bind(this);
  //   return $all(Array.from(iterable).map((item) => {
  //     const p = $resolve(item);
  //     try {
  //       return p.then(
  //         (value) => ({ status: 'fulfilled', value }),
  //         (reason) => ({ status: 'rejected', reason })
  //       );
  //     } catch (e) {
  //       return $reject(e);
  //     }
  //   }));
  // }`, true, {}, '>=12.4.0', 'Promise']
] as const;

const singleFilePackagesList = [
  ['has-property-descriptors', `const hasPropertyDescriptors = () => true;
hasPropertyDescriptors.hasArrayLengthDefineBug = () => false;
module.exports = hasPropertyDescriptors;`],
  ['gopd', 'module.exports = Object.getOwnPropertyDescriptor;'],
  ['has-proto', 'module.exports = () => true;'],
  ['get-symbol-description', `const { uncurryThis } = require('@nolyfill/shared');
module.exports = uncurryThis(Object.getOwnPropertyDescriptor(Symbol.prototype, 'description').get);`, { '@nolyfill/shared': 'workspace:*' }],
  ['is-array-buffer', `const { uncurryThis } = require('@nolyfill/shared');
const bL = uncurryThis(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);
module.exports = (obj) => {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  try {
    bL(obj);
    return true;
  } catch (_) {
    return false;
  }
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['is-shared-array-buffer', `const { uncurryThis } = require('@nolyfill/shared');
const bL = uncurryThis(Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, 'byteLength').get);
module.exports = (obj) => {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  try {
    bL(obj);
    return true;
  } catch (_) {
    return false;
  }
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['typed-array-buffer', `const { uncurryThis } = require('@nolyfill/shared');
module.exports = uncurryThis(Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Int8Array.prototype), 'buffer').get);`, { '@nolyfill/shared': 'workspace:*' }],
  ['typed-array-byte-length', `const { TypedArrayPrototype, uncurryThis } = require('@nolyfill/shared');
const typedArrayByteLength = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get);
module.exports = (value) => {
  try {
    return typedArrayByteLength(value);
  } catch (e) {
    return false;
  }
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['typed-array-byte-offset', `const { TypedArrayPrototype, uncurryThis } = require('@nolyfill/shared');
const typedArrayByteOffSet = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteOffset').get);
module.exports = (value) => {
  try {
    return typedArrayByteOffSet(value);
  } catch (e) {
    return false;
  }
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['typed-array-length', `const { TypedArrayPrototype, uncurryThis } = require('@nolyfill/shared');
const typedArrayLength = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'length').get);
module.exports = (value) => {
  try {
    return typedArrayLength(value);
  } catch (e) {
    return false;
  }
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['harmony-reflect', 'module.exports = Reflect;'],
  ['array-buffer-byte-length', `const { uncurryThis } = require('@nolyfill/shared');
const isArrayBuffer = require('@nolyfill/is-array-buffer');
const bL = uncurryThis(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);
module.exports = (ab) => {
  if (!isArrayBuffer(ab)) return NaN;
  return bL(ab);
};`, { '@nolyfill/is-array-buffer': 'workspace:*', '@nolyfill/shared': 'workspace:*' }],
  ['iterator.prototype', 'module.exports = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));'],
  ['available-typed-arrays', `module.exports = [
  'BigInt64Array', 'BigUint64Array',
  'Float32Array', 'Float64Array',
  'Int16Array', 'Int32Array', 'Int8Array',
  'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'
];`],
  ['which-typed-array', `const { uncurryThis } = require('@nolyfill/shared');

const cacheEntries = Object.entries([
  'BigInt64Array', 'BigUint64Array',
  'Float32Array', 'Float64Array',
  'Int16Array', 'Int32Array', 'Int8Array',
  'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'
].reduce((acc, typedArray) => {
  const proto = Object.getPrototypeOf(new globalThis[typedArray]());
  acc[\`$\${typedArray}\`] = uncurryThis((
    Object.getOwnPropertyDescriptor(proto, Symbol.toStringTag)
    || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(proto), Symbol.toStringTag)
  ).get);
  return acc;
}, Object.create(null)));

const tryTypedArrays = (value) => {
  let found = false;
  cacheEntries.forEach(([typedArray, getter]) => {
    if (!found) {
      try {
        if (\`$\${getter(value)}\` === typedArray) {
          found = typedArray.slice(1);
        }
      } catch (e) { /**/ }
    }
  });
  return found;
};

module.exports = (value) => {
  if (!value || typeof value !== 'object') { return false; }
  return tryTypedArrays(value);
};`, { '@nolyfill/shared': 'workspace:*' }],
  ['which-boxed-primitive', `module.exports = (value) => {
  if (value == null || (typeof value !== 'object' && typeof value !== 'function')) return null;
  if (typeof value === 'string') return 'String';
  if (typeof value === 'number') return 'Number';
  if (typeof value === 'boolean') return 'Boolean';
  if (typeof value === 'symbol') return 'Symbol';
  if (typeof value === 'bigint') return 'BigInt';
  if (typeof value === 'object') {
    if (Object.prototype.toString.call(value) === '[object String]') return 'String';
    if (Object.prototype.toString.call(value) === '[object Number]') return 'Number';
    if (Object.prototype.toString.call(value) === '[object Boolean]') return 'Number';
    if (
      Object.prototype.toString.call(value) === '[object Symbol]'
      && typeof value.valueOf() === 'symbol'
      && Symbol.prototype.toString.call(value).startsWith('Symbol(')
    ) return 'Symbol';
    try {
      BigInt.prototype.valueOf.call(value);
      return 'BigInt';
    } catch (_) {}
  }
};`],
  ['unbox-primitive', `module.exports = function unboxPrimitive(value) {
  if (value == null || (typeof value !== 'object' && typeof value !== 'function')) {
    throw new TypeError(value === null ? 'value is an unboxed primitive' : 'value is a non-boxed-primitive object');
  }
  if (typeof value === 'string' || Object.prototype.toString.call(value) === '[object String]') {
    return String.prototype.toString.call(value);
  }
  if (typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]') {
    return Number.prototype.valueOf.call(value);
  }
  if (typeof value === 'boolean' || Object.prototype.toString.call(value) === '[object Boolean]') {
    return Boolean.prototype.valueOf.call(value);
  }
  if (typeof value === 'symbol' || (
    Object.prototype.toString.call(value) === '[object Symbol]'
    && typeof value.valueOf() === 'symbol'
    && Symbol.prototype.toString.call(value).startsWith('Symbol(')
  )) {
    return Symbol.prototype.valueOf.call(value);
  }
  try {
    return BigInt.prototype.valueOf.call(value);
  } catch (_) {}
  throw new RangeError('unknown boxed primitive');
};`],
  ['is-regex', `module.exports = (value) => {
  if (!value || (typeof value !== 'object' && typeof value !== 'function')) return false;
  return Object.prototype.toString.call(value) === '[object RegExp]';
};`],
  ['safe-regex-test', `module.exports = (r) => {
  if (
    !r
    || (typeof r !== 'object' && typeof r !== 'function')
    || Object.prototype.toString.call(r) !== '[object RegExp]'
  ) {
    throw new TypeError('\`regex\` must be a RegExp');
  }
  return (s) => RegExp.prototype.exec.call(r, s) !== null;
};`],
  ['safe-array-concat', `const empty = [];
empty[Symbol.isConcatSpreadable] = true;
module.exports = (...args) => {
  for (let i = 0, l = args.length; i < l; i += 1) {
    const arg = args[i];
    if (arg && typeof arg === 'object' && typeof arg[Symbol.isConcatSpreadable] === 'boolean') {
      const arr = Array.isArray(arg) ? Array.prototype.slice.call(arg) : [arg];
      arr[Symbol.isConcatSpreadable] = true;
      args[i] = arr;
    }
  }
  return Array.prototype.concat.apply(empty, args);
};`],
  ['asynciterator.prototype', `/* globals AsyncIterator */
const asyncIterProto = typeof AsyncIterator === 'function' ? AsyncIterator.prototype : {};
if (!(Symbol.iterator in asyncIterProto)) {
  asyncIterProto[Symbol.iterator] = function () { return this; };
}
module.exports = asyncIterProto;`],
  ['is-weakref', `/* globals WeakRef: false */
module.exports = (value) => {
  if (typeof WeakRef === 'undefined') return false;
  if (!value || typeof value !== 'object') return false;
  try {
    WeakRef.prototype.deref.call(value);
    return true;
  } catch (e) {
    return false;
  }
};`],
  ['is-symbol', `module.exports = (value) => {
  if (typeof value === 'symbol') return true;
  if (Object.prototype.toString.call(value) !== '[object Symbol]') return false;
  try {
    if (typeof value.valueOf() !== 'symbol') return false;
    return Symbol.prototype.toString.call(value).startsWith('Symbol(');
  } catch (e) {
    return false;
  }
};`],
  ['is-string', `module.exports = (value) => {
  if (typeof value === 'string') return true;
  if (typeof value !== 'object') return false;
  try {
    String.prototype.valueOf.call(value);
    return true;
  } catch (e) { return false; }
};`],
  ['is-date-object', `module.exports = (value) => {
  if (typeof value !== 'object' || value === null) return false;
  try {
    Date.prototype.getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};`],
  ['es-set-tostringtag', `module.exports = (object, value, options = {}) => {
  if (options.force || !Object.prototype.hasOwnProperty.call(object, Symbol.toStringTag)) {
    Object.defineProperty(object, Symbol.toStringTag, {
      configurable: true,
      enumerable: false,
      value,
      writable: false
    });
  }
};`],
  ['define-properties', 'module.exports = require(\'@nolyfill/shared\').defineProperties', { '@nolyfill/shared': 'workspace:*' }],
  ['deep-equal', 'module.exports = (foo, bar) => require(\'dequal\').dequal(foo, bar)', { dequal: '2.0.3' }],
  ['is-arguments', `const isStandardArguments = (value) => ((value && typeof value === 'object' && Symbol.toStringTag in value)
  ? false
  : Object.prototype.toString.call(value) === '[object Arguments]');
const isLegacyArguments = (value) => (isStandardArguments(value)
  ? true
  : (
    value !== null
    && typeof value === 'object'
    && typeof value.length === 'number'
    && value.length >= 0
    && Object.prototype.toString.call(value) !== '[object Array]'
    && Object.prototype.toString.call(value.callee) === '[object Function]')
);
// isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
// eslint-disable-next-line prefer-rest-params -- detect arguments object
module.exports = (function () { return isStandardArguments(arguments); }()) ? isStandardArguments : isLegacyArguments`],
  ['is-generator-function', `const isFnRegex = /^\\s*(?:function)?\\*/;
// Node.js has full native support for generators since Node.js 6.4.0, so we don't need eval
const GeneratorFunction = Object.getPrototypeOf(function* () {});
module.exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') return false;
  if (isFnRegex.test(Function.prototype.toString.call(fn))) return true;
  return Object.getPrototypeOf(fn) === GeneratorFunction;
};`],
  // ['is-negative-zero', 'module.exports = (n) => n === 0 && (1 / n) === -Infinity;'],
  ['side-channel', `module.exports = () => {
  let $wm, $m;

  const get = (key) => {
    if (key && (typeof key === 'object' || typeof key === 'function')) {
      if ($wm) return $wm.get(key);
    } else if ($m) {
      return $m.get(key);
    }
    return undefined;
  };
  const set = (key, value) => {
    if (key && (typeof key === 'object' || typeof key === 'function')) {
      if (!$wm) $wm = new WeakMap();
      $wm.set(key, value);
    } else {
      if (!$m) $m = new Map();
      $m.set(key, value);
    }
  };
  const has = (key) => {
    if (key && (typeof key === 'object' || typeof key === 'function')) {
      if ($wm) {
        return $wm.has(key);
      }
    } else if ($m) {
      return $m.has(key);
    }
    return false;
  };
  const assert = (key) => {
    if (!has(key)) {
      throw new TypeError('Side channel does not contain the given key');
    }
  };
  return { get, set, has, assert };
};`],
  ['internal-slot', `const channel = new WeakMap();
const check = (O, slot) => {
  if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
    throw new TypeError('\`O\` is not an object');
  }
  if (typeof slot !== 'string') {
    throw new TypeError('\`slot\` must be a string');
  }
};
const has = (O, slot) => {
  check(O, slot);
  const slots = channel.get(O);
  return !!slots && Object.prototype.hasOwnProperty.call(slots, \`$\${slot}\`);
};
const get = (O, slot) => {
  check(O, slot);
  const slots = channel.get(O);
  return slots && slots[\`$\${slot}\`];
};
const set = (O, slot, V) => {
  check(O, slot);
  let slots = channel.get(O);
  if (!slots) {
    slots = {};
    channel.set(O, slots);
  }
  slots[\`$\${slot}\`] = V;
};
const assert = (O, slot) => {
  check(O, slot);
  if (!channel.has(O)) {
    throw new TypeError('Side channel does not contain the given key');
  }
  if (!has(O, slot)) {
    throw new TypeError(\`\\\`\${slot}\\\` is not present on \\\`O\\\`\`);
  }
};
module.exports = Object.freeze({ has, get, set, assert });`]
] as const;

const manualPackagesList = [
  'function-bind', // function-bind's main entry point is not uncurried, and doesn't follow es-shim API
  'has-tostringtag', // two entries (index.js, shams.js)
  'has-symbols', // two entries (index.js, shams.js)
  'es-iterator-helpers', // use rollup prebundle approach
  'globalthis' // globalthis package's entrypoint is a function, not the implementation
] as const;

const nonNolyfillPackagesList = [
  'nolyfill',
  '@nolyfill/shared'
] as const;

(async () => {
  const allPackagesList = [
    ...manualPackagesList,
    ...autoGeneratedPackagesList.map(pkg => pkg[0]),
    ...singleFilePackagesList.map(pkg => pkg[0])
  ].sort();

  const currentPackageJson = await currentPackageJsonPromise;

  const newPackageJson = {
    ...currentPackageJson,
    overrides: allPackagesList
      .reduce<Record<string, string>>((acc, packageName) => {
        acc[packageName] = `npm:@nolyfill/${packageName}@latest`;
        return acc;
      }, {}),
    pnpm: {
      ...currentPackageJson.pnpm,
      overrides: allPackagesList
        .reduce<Record<string, string>>((acc, packageName) => {
          acc[packageName] = `workspace:@nolyfill/${packageName}@*`;
          return acc;
        }, {})
    }
  };

  const cliAllPackagesTs = `/* Generated by create.ts */
/* eslint-disable */
export const allPackages = ${JSON.stringify(allPackagesList, null, 2)};\n`;

  await Promise.all([
    ...autoGeneratedPackagesList.map(pkg => createEsShimLikePackage(pkg[0], pkg[1], pkg[2])),
    ...singleFilePackagesList.map(pkg => createSingleFilePackage(pkg[0], pkg[1], pkg[2])),
    compareAndWriteFile(
      path.join(__dirname, 'package.json'),
      `${JSON.stringify(newPackageJson, null, 2)}\n`
    ),
    compareAndWriteFile(
      path.join(__dirname, 'packages/tools', 'cli', 'src', 'all-packages.ts'),
      cliAllPackagesTs
    ),
    compareAndWriteFile(
      path.join(__dirname, 'DOWNLOAD_STATS.md'),
      generateDownloadStats()
    )
  ]);

  console.log('Updating pnpm-lock.yaml...');
  await ezspawn.async('pnpm', ['i']);
})();

async function createEsShimLikePackage(
  packageName: string,
  extraDependencies: Record<string, string> = {},
  minimumNodeVersion = '>=12.4.0'
) {
  const entryContent = await fsPromises.readFile(
    path.join(__dirname, 'packages', 'data', 'es-shim-like', 'src', `${packageName}.ts`),
    { encoding: 'utf-8' }
  );
  const { code } = await transform(
    entryContent,
    {
      isModule: true,
      jsc: {
        parser: {
          syntax: 'typescript'
        }
      },
      module: { type: 'commonjs' }
    }
  );

  const pkg: VirtualPackage = {
    path: path.join(__dirname, 'packages/generated', packageName),
    files: {
      'entry.js': code + 'Object.assign(exports.default, exports);\nmodule.exports = exports.default;',
      'implementation.js': `'use strict';\nmodule.exports = require('./entry.js').implementation;\n`,
      'polyfill.js': `'use strict';\nmodule.exports = require('./entry.js').polyfill;\n`,
      'shim.js': `'use strict';\nmodule.exports = require('./entry.js').shim;\n`,
      'auto.js': `'use strict';\n/* noop */\n`,
      'index.js': `'use strict';\nmodule.exports = require('./entry.js').index();\n`
    },
    packageJson: {
      name: `@nolyfill/${packageName}`,
      version: (await currentPackageJsonPromise).version,
      repository: {
        type: 'git',
        url: 'https://github.com/SukkaW/nolyfill',
        directory: `packages/generated/${packageName}`
      },
      main: './index.js',
      license: 'MIT',
      files: ['*.js'],
      scripts: {},
      dependencies: {
        '@nolyfill/shared': 'workspace:*',
        ...extraDependencies
      },
      engines: {
        node: minimumNodeVersion
      }
    }
  };

  return writePackage(pkg);
}

async function createSingleFilePackage(
  packageName: string,
  implementation: string,
  extraDependencies: Record<string, string> = {},
  minimumNodeVersion = '>=12.4.0'
) {
  const currentPackageJson = await currentPackageJsonPromise;

  const pkg: VirtualPackage = {
    path: path.join(__dirname, 'packages/generated', packageName),
    files: {
      'index.js': `'use strict';\n${implementation}\n`
    },
    packageJson: {
      name: `@nolyfill/${packageName}`,
      version: currentPackageJson.version,
      repository: {
        type: 'git',
        url: 'https://github.com/SukkaW/nolyfill',
        directory: `packages/generated/${packageName}`
      },
      main: './index.js',
      license: 'MIT',
      files: ['*.js'],
      scripts: {},
      dependencies: extraDependencies,
      engines: {
        node: minimumNodeVersion
      }
    }
  };

  return writePackage(pkg);
}

function generateDownloadStats() {
  const pkgList = [
    ...autoGeneratedPackagesList.map(pkg => `@nolyfill/${pkg[0]}`),
    ...singleFilePackagesList.map(pkg => `@nolyfill/${pkg[0]}`),
    ...manualPackagesList.map(pkg => `@nolyfill/${pkg}`)
  ].sort();
  pkgList.unshift(...nonNolyfillPackagesList);

  return '| name | download |\n| ---- | -------- |\n'.concat(
    pkgList.map(
      pkg => `| \`${pkg}\` | [![npm](https://img.shields.io/npm/dt/${pkg}.svg?style=flat-square&logo=npm&logoColor=white&label=total%20downloads&color=333)](https://www.npmjs.com/package/${pkg}) |`
    ).join('\n')
  );
}

const ignoredFilesInPackages = new Set(['dist', 'node_modules', 'package.json']);
async function writePackage(pkg: VirtualPackage) {
  await fsPromises.mkdir(pkg.path, { recursive: true });
  let hasChanged = false;

  const promises: Array<Promise<void>> = [];
  const existingFileFullpaths = new Set<string>();

  const ps = new PathScurry(pkg.path);
  for await (const file of ps) {
    if (file.name.startsWith('.') || ignoredFilesInPackages.has(file.name)) {
      continue;
    }

    if (file.isFile()) {
      const relativePath = file.relativePosix();
      if (!(relativePath in pkg.files)) {
        // remove extra files
        hasChanged = true;

        promises.push(
          fsPromises.rm(path.join(pkg.path, relativePath))
        );
      } else {
        existingFileFullpaths.add(file.fullpathPosix());
      }
    }
  }

  const packageJsonPath = path.join(pkg.path, 'package.json');

  // write files, and check if they changed
  Object.entries(pkg.files).forEach(([file, content]) => {
    const filePath = path.join(pkg.path, file);
    promises.push(
      compareAndWriteFile(filePath, content, existingFileFullpaths)
        .then(written => {
          if (written) {
            hasChanged = true;
          }
        })
    );
  });

  // check if package.json changed
  promises.push((async () => {
    const existingPackageJson = (
      existingFileFullpaths.has(packageJsonPath)
      || await fileExists(packageJsonPath)
    ) ? JSON.parse(await fsPromises.readFile(packageJsonPath, 'utf8'))
      : {};

    // exclude version from comparison
    if (!dequal({ ...existingPackageJson, version: undefined }, { ...pkg.packageJson, version: undefined })) {
      hasChanged = true;
    }
  })());

  await Promise.all(promises);

  // if the package has changed, bump the version
  if (hasChanged) {
    pkg.packageJson.version = bumpVersion(pkg.packageJson.version || (await currentPackageJsonPromise).version);
    await fsPromises.writeFile(
      packageJsonPath,
      `${JSON.stringify(pkg.packageJson, null, 2)}\n`,
      'utf-8'
    );
    console.log(colors.blue(`[${pkg.packageJson.name}] bumped to ${pkg.packageJson.version}`));
  } else {
    console.log(colors.dim(`[${pkg.packageJson.name}] unchanged`));
  }
}

function bumpVersion(version: string) {
  // TODO: use semver
  const [major, minor, patch] = version.split('.');
  return `${major}.${minor}.${+patch + 1}`;
}
